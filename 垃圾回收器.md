### Java的垃圾回收器

按照执行机智，Java有四种垃圾回收器：

1. 串行垃圾回收器（Serial Garbage Collector）

2. 并行垃圾回收器（Parallel Garbage Collector）

3. 并发标记扫描垃圾回收器（CMS Garbage Collector）

4. G1垃圾回收器（G1 Garbage Collector）

因为GC线程会在安全点触发STW，让应用线程暂停下来，不同的垃圾回收器会影响STW的时长。在编程时可以通过向JVM传递参数选择垃圾回收器。

#### 串行垃圾回收器
串行垃圾回收器通过持有应用程序所有的线程进行工作。它为单线程环境设计，只使用一个单独的线程进行垃圾回收，通过冻结所有应用程序线程进行工作，所以可能不适合服务器环境。它最适合的是简单的命令行程序（单CPU、新生代空间较小及对暂停时间要求不是非常高的应用）。是client级别默认的GC方式。
通过JVM参数**-XX:+UseSerialGC可以使用串行垃圾回收器**。

#### 并行垃圾回收器
并行垃圾回收器也叫做 throughput collector 。它是JVM的默认垃圾回收器。与串行垃圾回收器不同，它使用多线程进行垃圾回收。相似的是，当执行垃圾回收的时候它也会冻结所有的应用程序线程。      适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式。可用-**XX:+UseParallelGC来指定使用并行垃圾回收器，用-XX:ParallelGCThreads=4来指定线程数**。
#### 并发标记扫描垃圾回收器
并发标记垃圾回收器使用多线程扫描堆内存，标记需要清理的实例，然后清理被标记过的实例。
并发标记垃圾回收器只会在下面两种情况持有应用程序所有线程。
1. 当标记的引用对象在年老代区；
2. 在进行垃圾回收的时候，堆内存的数据被并发的改变。      

相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量。如果我们可以为了更好的程序性能分配更多的CPU，那么并发标记上扫描垃圾回收器是更好的选择相比并发垃圾回收器。

通过JVM参数 **XX:+USeParNewGC 打开并发标记扫描垃圾回收器**。



### 怎么配置JVM垃圾回收来优化GC

#### 垃圾回收器类型

![垃圾回收器配置](E:\works\github\Note\res\垃圾回收器配置.png)

#### GC的优化配置

![垃圾回收的优化配置](E:\works\github\Note\res\垃圾回收的优化配置.png)