### Java内存分配模型

java虚拟机内存主要分为三部分：栈，堆，静态方法区 = 常量池 + 代码段 + 数据段。

* **栈**： 保存局部变量的值，包括：1.用来保存基本数据类型的值；2.保存类的**对象**，即堆区**实例**的引用

* **堆**： 用来存放动态产生的数据，比如new出来的对象， 同一个类的对象拥有各自的成员变量，存储在各自的堆中，但是他们共享该类的方法

* **常量池：**JVM为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量(基本类型，String)和对其他类型、方法、字段的符号引用。
* **代码段：**用来存放从硬盘上读取的源程序代码。
* **数据段：**用来存放static定义的静态成员。

**栈和堆： **在一个对象得创建过程中， class a = new Class(), a此时是存在于栈中得对象，可以通过这个对象得引用，找到对应在堆中的实例，一般在a使用完后，栈中的对象就会销毁，但是堆中的实例却要等没有任何对象引用后才会在一次GC中回收。

### 编码提高内存利用

#### 1. 减少不必要的GC

1. 不要显示调用 System.gc()，这会触发Full GC
2. 尽量减少临时对象的使用；一般临时变量都在新生代区，每次使用完，会由Scavenge GC进行。属于需要频繁GC的变量类型，减少临时变量就是减少垃圾
3. 对象不要显示置为Null，这些被置为NUll的对象会被标记为可回收的。不过对于确实用不到的对象显示置为Null可以预防内存泄漏。
4. 使用StringBuffer，而不是String来累加字符串；因为String累加表达式中每个String都是一个单独的 对象，会在常量池中占用空间，在回收的时候就会有多个垃圾
5. 少用静态变量；静态变量是全局对象，在程序运行期间不会被GC回收，会一直占用内存
6. 避免在短时间内大量创建和删除对象，这样会造成内存抖动，增加GC频率。比如不要再渲染函数中创建临时变量。

#### 2. 避免内存泄漏

因为各种原因，对象已经无用，但一直被持有，一直可到达。原因有：

1. 被生命周期极长的集合类不当持有，是Java内存泄漏的首因。这些集合类的生命周期通常极长，而且是一个辅助管理性质的对象，在一个业务事务运行完后，如果没有将某个业务对象主动的从中清除的话，这个集合就会吃越来越多内存，可以用WeakReference，如WeakHashMap，使得它持有的对象不增加对象的引用数。
2. 变量的作用域设置的不合理，Scope定义不对。比如方法的局部变量定义成类的变量，类的静态变量等。
3. 处理异常时没有加finally{}来释放某些资源。
4. 内部类持有外部对象的隐式引用
5. **静态集合类引起内存****泄漏**
    , HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致,
    不用的时候置为Null
6. **删除监听器**
7. **单列****模式的错误使用。**在单列类中持有外部对象的引用而又没有销毁，和3的情况一样
